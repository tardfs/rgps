\documentclass[a4paper]{article}
%\documentclass[twocolumn,a4paper]{proc}
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}
\usepackage[cmex10]{amsmath}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage{pscyr}
\usepackage[pdftex]{graphicx}
%\usepackage{fancyhdr}
%\pagestyle{fancy}
\renewcommand{\rmdefault}{fjn}
\setlength{\textwidth}{170mm}
\setlength{\textheight}{240mm}
\voffset=-20mm
\hoffset=-20mm
\title{Реализация процедуры L1}
%\lhead{Кафедра "Управление и моделирование систем"}
%\lfoot{Семинар 1}
\begin{document}
%\maketitle
%\begin{abstract}
%Рассматриваются методы ...
%\end{abstract}
\section{Статический фильтр Калмана}
$(\Delta x,\Delta y,\Delta z)$ - искомый вектор относительных координат в системе ECEF.\\
Кодовая псевдодальность, м:
\begin{equation}
\rho=r+c(\delta t_r-\delta t_{sv})+T+I+m_\rho +\nu_\rho
\end{equation}
$r$ - истинное расстояние от приемника до спутника, м \\
$c$ - скорость света м/с \\
$\delta t_r$ - ошибка времени в приемнике, с \\
$\delta t_{sv}$ - ошибка времени на спутнике, с \\
$T$ - тропосферная ошибка, м \\
$I$ - Ионосферная задержка, м \\
$m_\rho$ - Ошибка вследствие многолучевого распространения, м \\
$\nu_\rho$ - Ошибка вызванная тепловым шумом, м \\
Фазовые измерения, м:
\begin{equation}
\phi=\lambda^{-1}(r+c(\delta t_r-\delta t_{sv})+T+I+m_\phi +\nu_\phi)+N
\end{equation}
$\phi$ - фазовое измерение GPS, циклы (количество длин волн) \\
$\lambda$ - длина волны, м/цикл \\
$m_\phi$ - ошибка фазового измерения, вызванная многолучевым распространением, циклы \\
$nu_\phi$ - ошибка фазового измерения из-за теплового шума, циклы \\
$N$ - фазовая неоднозначность (целое число длин волн, неизвестное на стороне приемника). \\
\\
Первая разность фазовых измерений между двумя приемниками $A$ и $B$ относительно $k$-го спутника позволяет избавиться от ошибки $\delta t_{sv}^k$ времени на $k$-ом спутнике:
\begin{align*}
\Delta\phi_{AB}^k = &\phi_{A}^k-\phi_{B}^k =\\
&\lambda^{-1}(r_A^k+c(\delta t_{r_A}-\delta t_{sv}^k)+T_A^k+I_A^k+m_{\phi_A}^k +\nu_{\phi_A})^k+N_A^k - \\
&(\lambda^{-1}(r_B^k+c(\delta t_{r_B}-\delta t_{sv}^k)+T_B^k+I_B^k+m_{\phi_B}^k +\nu_{\phi_B})^k+N_B^k) = \\
\\
&\lambda^{-1}(\Delta r^k_{AB}+c\delta t_{r_{AB}}+\Delta T^k_{AB}+\Delta I^k_{AB}+\Delta m^k_{\phi_{AB}} +\Delta\nu_{\phi^k_{AB}})+\Delta N^k_{AB}  \\
\end{align*}

Вторая разность образуется как разность первых разностей для двух спутников $j$ и $k$. Вычисление второй разности позволяет 
устранить разность ошибок времени $\delta t_{r_{AB}}$ между приемниками $A$ и $B$:
\begin{align}
\Delta\nabla\phi_{AB}^{jk} = &\Delta\phi_{AB}^j-\Delta\phi_{AB}^k =\nonumber \\
& \lambda^{-1}(\Delta r^j_{AB}+c\delta t_{r_{AB}}+\Delta T_{AB}^j+\Delta I_{AB}^j+\Delta m^j_{\phi_{AB}} +\Delta\nu_{\phi^j_{AB}})+\Delta N^j_{AB} -\nonumber \\
& (\lambda^{-1}(\Delta r^k_{AB}+c\delta t_{r_{AB}}+\Delta T_{AB}^k+\Delta I_{AB}^k+\Delta m^k_{\phi_{AB}} +\Delta\nu_{\phi^k_{AB}})+\Delta N^k_{AB})  \\
& \nonumber \\
& \lambda^{-1}(\Delta\nabla r^{jk}_{AB}+\Delta\nabla T_{AB}^{jk}+\Delta\nabla I_{AB}^{jk}+\Delta\nabla m^{jk}_{\phi_{AB}} +\Delta\nabla\nu_{\phi^{jk}_{AB}})+\Delta\nabla N^{jk}_{AB} \nonumber \\
\end{align}

Если приемник двухчастотный, то вместо простого фазового измерения $\phi$ используется сумма 
(narrowline) $\phi_{NL}=\phi_{L1}+\phi_{L2}$ или разность (wideline) $\phi_{WL}=\phi_{L1}-\phi_{L2}$ 
фазовых измерений на данном приемнике. 
Такой подход значительно упрощает разрешение неоднозначности
фазовых измерений (определение истинного значения $N$).

Фильтр Калмана представляет собой итерационную процедуру, где каждая итерация состоит из двух этапов:
прогноза и коррекции на основе измерения. Прогноз вектора состояния:
\begin{align}
x^-_k = \Phi_{k-1} x_{k-1}
\end{align}
Прогноз корреляционной матрицы вектора состояния:
\begin{align}
P^-_k = \Phi_{k-1} P_{k-1} \Phi_{k-1}^T + Q_d
\end{align}
Коррекция вектора состояния осуществляется на основе наблюдений:
\begin{align}
x_k = x^-_k + K_k(z_k-Hx^-_k)
\end{align}
Здесь $K_k$ - матричный коэффициент усиления Калмана на $k$-м шаге.
\begin{align}
K_k = P_kH^T(HP_kH^T+R)^{-1}
\end{align}
Аналогичным образом обновляется корреляционная матрица вектора состояния:
\begin{align}
P_k = P^-_k - K_kHP^-_k
\end{align}

Прогноз вектора состояния
\begin{equation}
\begin{array}{ccc}
\label{eqn_1}
x_{k+1} &=\Phi_k & x_k \\
\begin{bmatrix}
\Delta x \\
\Delta y \\
\Delta z \\
\Delta\nabla\phi^{1,2}_{AB} \\
\Delta\nabla\phi^{1,3}_{AB} \\
\vdots \\
\Delta\nabla\phi^{1,numSat}_{AB} \\
\end{bmatrix}_{k+1} &= 
\begin{bmatrix}
1 & 0 & \ldots & 0 \\
0 & 1 & \ldots & 0 \\
\vdots & \vdots & \ddots & \vdots \\
0 & 0 & \ldots & 1 \\
\end{bmatrix} & 
\begin{bmatrix}
\Delta x \\
\Delta y \\
\Delta z \\
\Delta\nabla\phi^{1,2}_{AB} \\
\Delta\nabla\phi^{1,3}_{AB} \\
\vdots \\
\Delta\nabla\phi^{1,numSat}_{AB} \\
\end{bmatrix}_{k}
\end{array}
\end{equation}
Прогноз ковариационной матрицы вектора состояния
\begin{align}
& P_{k+1} =\Phi_kP_k\Phi_k^T+Q_d \\
& \begin{bmatrix} \nonumber
\sigma_{x,x} & \sigma_{x,y} & \sigma_{x,z} & \ldots & \ldots & \ldots & \ldots \\
\sigma_{y,x} & \sigma_{y,y} & \sigma_{y,z} & \ldots & \ldots & \ldots & \ldots \\
\sigma_{z,x} & \sigma_{z,y} & \sigma_{z,z} & \ldots & \ldots & \ldots & \ldots \\
\ldots & \ldots & \ldots & \sigma\Delta\nabla\phi^{1,2}_{AB}  & \ldots & \ldots & \ldots \\
\ldots & \ldots & \ldots & \ldots & \sigma\Delta\nabla\phi^{1,3}_{AB} & \ldots & \ldots \\
\ldots & \ldots & \ldots & \ldots & \ldots  & \ddots & \ldots \\
\ldots & \ldots & \ldots & \ldots & \ldots & \ldots & \sigma\Delta\nabla\phi^{1,numSat}_{AB} \\
\end{bmatrix}_{k+1}=\\
\begin{bmatrix}
1 & 0 & \ldots & 0 \\
0 & 1 & \ldots & 0 \\
\vdots & \vdots & \ddots & \vdots \\
0 & 0 & \ldots & 1 \\
\end{bmatrix}  
& \begin{bmatrix} \nonumber
\sigma_{x,x} & \sigma_{x,y} & \sigma_{x,z} & \ldots & \ldots & \ldots & \ldots \\
\sigma_{y,x} & \sigma_{y,y} & \sigma_{y,z} & \ldots & \ldots & \ldots & \ldots \\
\sigma_{z,x} & \sigma_{z,y} & \sigma_{z,z} & \ldots & \ldots & \ldots & \ldots \\
\ldots & \ldots & \ldots & \sigma\Delta\nabla\phi^{1,2}_{AB}  & \ldots & \ldots & \ldots \\
\ldots & \ldots & \ldots & \ldots & \sigma\Delta\nabla\phi^{1,3}_{AB} & \ldots & \ldots \\
\ldots & \ldots & \ldots & \ldots & \ldots  & \ddots & \ldots \\
\ldots & \ldots & \ldots & \ldots & \ldots & \ldots & \sigma\Delta\nabla\phi^{1,numSat}_{AB} \\
\end{bmatrix}_{k}
&\begin{bmatrix}
1 & 0 & \ldots & 0 \\
0 & 1 & \ldots & 0 \\
\vdots & \vdots & \ddots & \vdots \\
0 & 0 & \ldots & 1 \\
\end{bmatrix} +\\
&\begin{bmatrix}
q_p\Delta t & 0 & 0 & 0 & \ldots & 0 \\
0  & q_p\Delta t & 0 & 0 & \ldots & 0 \\
0  & 0 & q_p\Delta t & 0 & \ldots & 0 \\
0  & 0 & 0 & q_N\Delta t & \ldots & 0 \\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
0  & 0 & 0 & 0 & \ldots & q_N\Delta t \\
\end{bmatrix}  
\end{align}
Уравнение наблюдения
\begin{equation}
\label{eqn_4}
\begin{array}{cccc}
z_k = & H & x_k & + v_k \\
\begin{bmatrix}
\Delta\nabla\rho^{1,2}_{AB} \\
\Delta\nabla\rho^{1,3}_{AB} \\
\vdots \\
\Delta\nabla\rho^{1,numSat}_{AB} \\
\Delta\nabla\phi^{1,2}_{AB} \\
\Delta\nabla\phi^{1,3}_{AB} \\
\vdots \\
\Delta\nabla\phi^{1,numSat}_{AB} \\
\end{bmatrix}_{k} &= 
\begin{bmatrix}
(\mathbf{e^1}-\mathbf{e^2}) & 0 & 0 & \ldots & 0 \\
(\mathbf{e^1}-\mathbf{e^3}) & 0 & 0 & \ldots & 0 \\
\ldots & \ldots & \ldots & \ldots  & \ldots \\ 
(\mathbf{e^1}-\mathbf{e^{S}}) & 0 & 0  & \ldots & 0 \\
\lambda^{-1}(\mathbf{e^1}-\mathbf{e^2}) & 1 & 0  & \ldots & 0 \\
\lambda^{-1}(\mathbf{e^1}-\mathbf{e^3}) & 0 & 1  & \ldots & 0 \\
\ldots & \ldots & \ldots & \ldots \\
\lambda^{-1}(\mathbf{e^1}-\mathbf{e^{S}}) & 0 & 0  & \ldots & 1 \\
\end{bmatrix} &
\begin{bmatrix}
\Delta x \\
\Delta y \\
\Delta z \\
\Delta\nabla N^{1,2}_{AB} \\
\Delta\nabla N^{1,3}_{AB} \\
\vdots \\
\Delta\nabla N^{1,numSat}_{AB} \\
\end{bmatrix}_{k}
\end{array}
\end{equation}

Единичный вектор $\mathbf{e^n}$ это строка $\mathbf{e^n}=(e^n_x,e^n_y,e^n_z)$. Этот вектор определяет направление 
от приемника на $n$-ый спутник. Так как расстояние от приемника до спутника примерно $20\times 10^6$м, 
то эти вектора для обоих приемников совпадают с высокой точностью. В документе \cite{Comstock} указано, что эти вектора
вычисляет процедура фильтра Калмана, но я пока не вижу как она это может сделать, так как эти вектора там 
как раз и используются как элементы матриц которые определяют параметры фильтра. Для начала буду вычислять эти 
вектора грубо по абсолюным координатам приемника и спутника. Тогда матрица наблюдения определяется следующим образом:
\begin{equation}
H = 
\begin{bmatrix}
\Delta e^{1,2}_x & \Delta e^{1,2}_y & \Delta e^{1,2}_z & 0 & 0 & \ldots & 0 \\
\Delta e^{1,3}_x & \Delta e^{1,3}_y & \Delta e^{1,3}_z & 0 & 0 & \ldots & 0 \\
\ldots & \ldots & \ldots & \ldots  & \ldots \\ 
\Delta e^{1,S}_x & \Delta e^{1,S}_y & \Delta e^{1,S}_z & 0 & 0 & \ldots & 0 \\
\lambda^{-1}(\Delta e^{1,2}_x & \Delta e^{1,2}_y & \Delta e^{1,2}_z) & 1 & 0  & \ldots & 0 \\
\lambda^{-1}(\Delta e^{1,3}_x & \Delta e^{1,3}_y & \Delta e^{1,3}_z) & 0 & 1  & \ldots & 0 \\
\ldots & \ldots & \ldots & \ldots & \ldots & \ldots & \ldots \\
\lambda^{-1}(\Delta e^{1,S}_x & \Delta e^{1,S}_y & \Delta e^{1,S}_z) & 0 & 0  & \ldots & 1 \\
\end{bmatrix}
\end{equation}

\begin{figure}[h]
\centering
\includegraphics{kalman_ecef_vars.png}
\caption{Дисперсия относительных координат}
\end{figure}
\begin{figure}[h]
\centering
\includegraphics{kalman_dd_vars.png}
\caption{Дисперсия вторых разностей}
\end{figure}
\begin{figure}[h]
\centering
\includegraphics{comstock_vars.png}
\caption{Comstock}
\end{figure}


\begin{thebibliography}{1}
\bibitem{Comstock} Stephen J. Comstock, 
Development of a Low-Latency, High Data Rate, Differential GPS Relative Positioning System for 
UAV Formation Flight control. {\em THESIS Presented to the Faculty Department of Electrical and Computer 
Engineering Graduate School of Engineering and Management Air Force Institute of Technology}, 2006.
\bibitem{Welch} Greg Welch, Gary Bishop, An Introduction to the Kalman Filter. ACM-2001. ACM Inc.
\bibitem{LambdaFAQ} Peter Joosten, Christian Tiberius, Lambda: FAQs. - GPS Solutions (2002) 6:109–114. http://www.utdallas.edu/~aiken/GPSCLASS/lambdaambigfulltext.pdf
\bibitem{Tiberius} Paul de Jonge, Tiberius C. The LAMBDA method for integer ambiguity estimation:implementation aspects. http://www.citg.tudelft.nl
\end{thebibliography}
\end{document}


